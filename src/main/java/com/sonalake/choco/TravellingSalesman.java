/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.sonalake.choco;

import org.chocosolver.solver.Model;
import org.chocosolver.solver.Solver;
import org.chocosolver.solver.constraints.extension.Tuples;
import org.chocosolver.solver.search.strategy.Search;
import org.chocosolver.solver.search.strategy.selectors.values.IntDomainMin;
import org.chocosolver.solver.search.strategy.selectors.variables.MaxRegret;
import org.chocosolver.solver.variables.IntVar;

import java.util.Arrays;

import static java.util.Arrays.stream;

public class TravellingSalesman {
  public void doIt() {
    // GR17 is a set of 17 cities, from TSPLIB. The minimal tour has length 2085.

    // number of cities
    int numberOfCities = 17;

    // matrix of distances
    int[][] matrixOfDistances = new int[][]{
      {0, 633, 257, 91, 412, 150, 80, 134, 259, 505, 353, 324, 70, 211, 268, 246, 121},
      {633, 0, 390, 661, 227, 488, 572, 530, 555, 289, 282, 638, 567, 466, 420, 745, 518},
      {257, 390, 0, 228, 169, 112, 196, 154, 372, 262, 110, 437, 191, 74, 53, 472, 142},
      {91, 661, 228, 0, 383, 120, 77, 105, 175, 476, 324, 240, 27, 182, 239, 237, 84},
      {412, 227, 169, 383, 0, 267, 351, 309, 338, 196, 61, 421, 346, 243, 199, 528, 297},
      {150, 488, 112, 120, 267, 0, 63, 34, 264, 360, 208, 329, 83, 105, 123, 364, 35},
      {80, 572, 196, 77, 351, 63, 0, 29, 232, 444, 292, 297, 47, 150, 207, 332, 29},
      {134, 530, 154, 105, 309, 34, 29, 0, 249, 402, 250, 314, 68, 108, 165, 349, 36},
      {259, 555, 372, 175, 338, 264, 232, 249, 0, 495, 352, 95, 189, 326, 383, 202, 236},
      {505, 289, 262, 476, 196, 360, 444, 402, 495, 0, 154, 578, 439, 336, 240, 685, 390},
      {353, 282, 110, 324, 61, 208, 292, 250, 352, 154, 0, 435, 287, 184, 140, 542, 238},
      {324, 638, 437, 240, 421, 329, 297, 314, 95, 578, 435, 0, 254, 391, 448, 157, 301},
      {70, 567, 191, 27, 346, 83, 47, 68, 189, 439, 287, 254, 0, 145, 202, 289, 55},
      {211, 466, 74, 182, 243, 105, 150, 108, 326, 336, 184, 391, 145, 0, 57, 426, 96},
      {268, 420, 53, 239, 199, 123, 207, 165, 383, 240, 140, 448, 202, 57, 0, 483, 153},
      {246, 745, 472, 237, 528, 364, 332, 349, 202, 685, 542, 157, 289, 426, 483, 0, 336},
      {121, 518, 142, 84, 297, 35, 29, 36, 236, 390, 238, 301, 55, 96, 153, 336, 0}
    };


    // get the maximum distance from the 2-D  array
    int max = stream(matrixOfDistances).flatMapToInt(Arrays::stream).max().orElse(0);

    // A new model instance
    Model model = new Model("TSP");

    // VARIABLES
    // For each city, the next one visited in the route
    IntVar[] nextCity = model.intVarArray("succ", numberOfCities, 0, numberOfCities - 1);

    // For each city, the distance to the next visited one
    IntVar[] distanceToNextCity = model.intVarArray("dist", numberOfCities, 0, max);

    // Total distance of the route
    IntVar totalRouteDistance = model.intVar("Total distance", 0, max * numberOfCities);

    // CONSTRAINTS

    // What we want to do here is make sure that we constrain the solution so that
    // from each city "i" we will only try to connect to another city that isn't "i".
    // We also want to constrain this by the distance between these cities

    // We do this by adding a tuple of options for each city for the possible distance
    // from that city to any others, and then add this to a table for all possible
    // next cities.
    for (int i = 0; i < numberOfCities; i++) {
      Tuples tuples = new Tuples(true);
      for (int j = 0; j < numberOfCities; j++) {
        // Add in a distance between these two cities
        // (just not a 0 from the city to itself ;) )
        if (j != i) {
          tuples.add(j, matrixOfDistances[i][j]);
        }
      }
      // The Table constraint ensures that one combination holds
      // in a solution where:
      // nextCity[i]: the variable that defines what is the next city after the ith
      // distanceToNextCity[i]: the variable that the distance between i and nextCity[i]
      // tuples: the list of constraints for what is permitted, namely the distances from i to all the cities that are not i
      model.table(nextCity[i], distanceToNextCity[i], tuples).post();
    }

    // The route forms a single circuit of size "numberOfCities", visiting all cities
    // This "subCircuit" makes sure we don't pass through the same city twice.
    model.subCircuit(nextCity, 0, model.intVar(numberOfCities)).post();

    // Defining the total distance as being a sum over all the "distances to next city.
    // We want to minimise this total distance, so we define that as the objective
    model.sum(distanceToNextCity, "=", totalRouteDistance).post();
    model.setObjective(Model.MINIMIZE, totalRouteDistance);

    // now we solve this :)
    Solver solver = model.getSolver();
    solver.setSearch(
      Search.intVarSearch(
        new MaxRegret(),
        new IntDomainMin(),
        distanceToNextCity
      )
    );
    solver.showShortStatistics();

    // now dump all the results
    while (solver.solve()) {
      int current = 0;
      System.out.printf("C_%d ", current);
      for (int j = 0; j < numberOfCities; j++) {
        System.out.printf("-> C_%d ", nextCity[current].getValue());
        current = nextCity[current].getValue();
      }
      System.out.printf("\nTotal distance = %d\n", totalRouteDistance.getValue());
      System.out.println("------------------------------------------------------------------------------------");

    }
  }

  public static void main(String[] args) {
    new TravellingSalesman().doIt();
  }
}
